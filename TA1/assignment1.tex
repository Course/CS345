\documentclass{article}
\usepackage{graphicx}
\usepackage{alltt}
\usepackage{wrapfig}
\usepackage{multicol}
\usepackage{epsfig}
\usepackage{amsmath}
\textwidth 6in
\addtolength{\oddsidemargin}{-0.5in}
\textheight 9in
\addtolength{\topmargin}{-0.5in}
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.5cm}
\setlength{\columnsep}{5cm}
\topskip 0.0in
%\pagestyle{empty}
\thispagestyle{empty}
\title{Assignment 1}
\author{Satvik Chauhan (Y9521),Pankaj More (Y9402)}
%\date{August 04, 2004}
\date{}


\begin{document}
\maketitle
\section*{Question 2}
We will define our own coordinate system and assume that the conversion from the given system to ours can be done in $O(1)$ time for each point . We define the coordinate system as follows . 
\begin{itemize}
\item Choose any arbitrary point on the circle which is not the endpoint of any chord .
\item This is called zero . Now travel clockwise from this point .
\item The degrees we travel from this point to the concerned point is the value of that point . 
\item So minimum value can be 0 and maximum can be 360. 
\end{itemize}
Now algorithm to give the no. of intersections is : \\
\begin{itemize}
\item We assume that point are given in some coordinate system with $(x_i,y_i)$ as the two endpoints of the $i^{th}$ chord.
\item We convert each point into the coordinate system described above and for a chord the point which has lower value (closer to the zero point) is marked as the start point of the chord and the other as the corresponding end point.
This takes O(n) time.
\item Now we sort all the points (including all the start and end points).
\item We assume all these points are nodes and contain information about which chord they belong to and also a pointer to the other end of the chord. 
\item For each point taken from the sorted list we do the following :
	\begin{itemize}
	\item If it is a start point we add it to the BST where each node is augmented with the size of the subtree rooted at that node (We have to increase the size field of all the nodes along the path where we insert the given node). This takes O(log n) time because height of the BST in the worst case containing all the start nodes can not be greater than log n because there are only n chords and insertion in such a BST can not take more than O(log n).
	\item If it is an end point then we count the number of points greater than the corresponding start point (which can be found as we are keeping the pointer for it from the end point). We travel the BST from the root till we find the start point (maximum O(log n) steps) . While travelling along the path if we move left then we add (1 + size of right subtree which is stored in the augmented BST and can be found in O(1) time) and if we move right then we dont add anything. Thus the number of points greater than the given point can be found in O(log n) time. 
    \item This number correspond to the number of chords intersecting the given chord.
    \item Delete the start point from the BST. This takes O(log n) time (We have to decrease the size field accordingly for the nodes on the path ).
	\end{itemize}
	We sum all the points of intersections . Since we remove the start point from the the BST after counting its intersections we are making sure that we count each intersection only once and not twice. 
	Since we are doing this for n chords thus total O(n(log n)) time. 
\item Total time = O(n) + O(n(log n)) + O(n(log n)) = O(n(log n)).
\end{itemize}
\begin{alltt}
findintersection(\(<(x\sb1,y\sb1),(x\sb2,y\sb2),\ldots ,(x\sb{n},y\sb{n})>\)) 
\{ 
for (i=1;i<=n;i++)
    \{
        Convert the point into above coordinate system and store into \((s\sb{i},e\sb{i})\) 
        such that \(s\sb{i} < e\sb{i}\) .
    \}
\}                                                                           // O (n)
count <- 0 
B <- Empty BST where each node augmented with the size field
Points <- sort (\(<s\sb1,s\sb2,\ldots,s\sb{n},e\sb1,e\sb2,\ldots,e\sb{n}>\))                              //O(n(log n)) 
foreach point p in Points do 
    \{
    if p is a start point then insert it into the augmented BST B            // O(log n)
    else 
        \{  
            count <- count + points greater than start point in the BST      // O(log n)
            delete corresponding startpoint from B                           // O(log n)
        \}
    \}                                                                       // O(n(log n))
    return count 
\}
\end{alltt}
	
 
\section*{Question 4}
Let : 
\[r = x * z \] is the convolution of 2 vectors x and z and \\
\[s = y * z \] is the convolution of 2 vectors y and z such that
\[x = (x_{0},x_{1},...,x_{n-1})\]
\[y = (y_{0},y_{1},...,y_{n-1})\]
\[z = (z_{0},z_{1},...,z_{n-1})\]
\[x_{i} = q_{i+1}\]
\[y_{i} = q_{n-i}\]
\[z_{j} = 1/(j+1)^2\]

\subsection*{Claim:} \[F_j = Cq_j[r_{j-2} - s_{n-j-1}]\]

\subsection*{Proof:}
\begin{align*}
r_{j-2} & = \sum_{l+m=j-2} x_lz_m \\
&= \sum_{l+m=j-2} \frac{q_{l+1}}{(m+1)^2} \\
&= \frac{q_1}{(j-1)^2} + \frac{q_2}{(j-2)^2} + ... + \frac{q_{j-1}}{1^2} \\
&= \sum_{i<j} \frac{q_i}{(j-i)^2} \\
s_{n-j-1} & = \sum_{l+m=n-j-1} y_lz_m \\
&= \sum_{l+m=n-j-1} \frac{q_{n-l}}{(m+1)^2} \\
&= \frac{q_n}{(n-j)^2} + \frac{q_{n-1}}{(n-j-i)^2} + ... + \frac{q_{j+1}}{1^2} \\
&= \sum_{i>j} \frac{q_i}{(j-i)^2} \\ 
\end{align*}

Hence , 
\[F_j = Cq_j[\sum_{i<j} \frac{q_{i}}{(j-i)^2} - \sum_{i>j} \frac{q_{i}}{(j-i)^2}  ]\] 
\\
Note: We assume $r_j = 0$ for $j < 0$ and same in the case of $s_j$.

\subsection*{Runtime analysis:}
Using the result of the upper bound of running time of the algorithm to compute the convolution of 2 vectors of degree n in O(nlogn) , we can compute the vectors r and s in O(nlogn) time.
For any particular value of j in $F_j$ , we only have to compute one subtraction and two multiplication which is constant time. Hence computing $F_j$ for all values of j is O(n) time. \\
Therefore , total running time of the above algorithm is O(nlogn).


\end{document}
